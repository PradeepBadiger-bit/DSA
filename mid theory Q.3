#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// --- Tree Node Definition ---
typedef struct TreeNode {
    char character;
    int frequency;
    struct TreeNode *left, *right;
} TreeNode;

TreeNode* findNode(TreeNode* root, char target) {
    if (root == NULL) {
        return NULL;
    }
    if (root->character == target) {
        return root; // Character found
    }
    // Recursively search in the left subtree
    TreeNode* foundNode = findNode(root->left, target);
    if (foundNode != NULL) {
        return foundNode;
    }
    // If not in left, search in the right subtree
    return findNode(root->right, target);
}

// --- Algorithm to build the binary tree ---
TreeNode* buildTree(const char* input) {

    TreeNode* root = NULL;
    // Simple array-based queue to manage parent nodes for level-order insertion
    TreeNode* insertion_queue[100]; 
    int front = 0, rear = 0;

    for (int i = 0; input[i] != '\0'; i++) {
        char c = input[i];
        
        // Search the existing tree for the character
        TreeNode* existingNode = findNode(root, c);

        if (existingNode) {
            // If the character already exists, just increment its frequency
            existingNode->frequency++;
        } else {
            // This is a new character, create a new node
            TreeNode* newNode = malloc(sizeof(TreeNode));
            *newNode = (TreeNode){c, 1, NULL, NULL};

            // Enqueue the new node so it can become a parent for future nodes
            insertion_queue[rear++] = newNode;

            // Insert the new node at the first available spot in level-order
            if (!root) {
                root = newNode;
            } else {
                TreeNode* parent = insertion_queue[front]; // Peek at the current parent
                if (!parent->left) {
                    parent->left = newNode;
                } else {
                    parent->right = newNode;
                    front++; // This parent is now full, dequeue it
                }
            }
        }
    }
    return root;
}

// Prints the tree level by level and frees the allocated memory.
void traverseAndFreeTree(TreeNode* root) {
    if (!root) {
        printf("Tree is empty.\n");
        return;
    }
    TreeNode* queue[100];
    int front = 0, rear = 0;
    queue[rear++] = root;

    printf("\nLevel order traversal (character, frequency):\n");
    while (front < rear) {
        TreeNode* current = queue[front++]; // Dequeue
        printf("(%c, %d) ", current->character, current->frequency);

        if (current->left) queue[rear++] = current->left;
        if (current->right) queue[rear++] = current->right;
        free(current); // Free the node after processing it
    }
    printf("\n");
}

int main() {
    char userInput[100];
    printf("Enter a string to analyze: ");
    fgets(userInput, sizeof(userInput), stdin);
    userInput[strcspn(userInput, "\n")] = 0;

    TreeNode* root = buildTree(userInput);
    traverseAndFreeTree(root);
    
    return 0;
}
